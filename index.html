<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="manifest" href="./manifest.webmanifest">
<meta name="theme-color" content="#2f5cff">
  <title>Mini Task (Mobile)</title>
  <style>
    body {
      margin: 0;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP", sans-serif;
      background: #f6f7fb;
      color: #111;
    }
    .wrap {
      max-width: 680px;
      margin: 0 auto;
      padding: 16px;
    }
    .card {
      background: #fff;
      border-radius: 18px;
      padding: 16px;
      box-shadow: 0 8px 24px rgba(0,0,0,.06);
    }
    h1 {
      font-size: 18px;
      margin: 0 0 12px;
    }
    .row {
      display: flex;
      gap: 10px;
      align-items: stretch;
    }
    /* input ã§ã¯ãªã textarea ã‚’ä½¿ã†ï¼ˆIMEå¤‰æ›ç¢ºå®šã§å‹æ‰‹ã«è¿½åŠ ã•ã‚Œãªã„ï¼‰ */
    input, textarea {
      flex: 1;
      font-size: 16px;
      padding: 14px 14px;
      border-radius: 14px;
      border: 1px solid #e4e6ef;
      outline: none;
      resize: none;
      line-height: 1.3;
    }
    input:focus, textarea:focus {
      border-color: #b7c5ff;
      box-shadow: 0 0 0 4px rgba(90,120,255,.12);
    }
    button {
      font-size: 16px;
      padding: 14px 16px;
      border: 0;
      border-radius: 14px;
      background: #2f5cff;
      color: #fff;
      font-weight: 700;
      cursor: pointer;
      -webkit-tap-highlight-color: transparent;
      white-space: nowrap;
    }
    button:active { transform: translateY(1px); }
    button:disabled {
      opacity: .5;
      cursor: not-allowed;
    }
    .voice {
      background: #0f766e;
    }
    .voice.listening {
      background: #b42318;
    }
    .voice-status {
      margin-top: 8px;
      font-size: 13px;
      color: #0f766e;
      min-height: 1.2em;
    }

    ul {
      list-style: none;
      padding: 0;
      margin: 14px 0 0;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    li {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      padding: 14px 14px;
      border-radius: 14px;
      border: 1px solid #eef0f6;
      background: #fbfbfe;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
    }
    .text {
      flex: 1;
      font-size: 16px;
      line-height: 1.3;
      word-break: break-word;
      white-space: pre-wrap; /* textareaã®æ”¹è¡Œã‚’ä¿æŒ */
    }
    .done .text { text-decoration: line-through; opacity: .55; }
    .actions { display: flex; gap: 8px; }
    .ghost {
      background: #eef1ff;
      color: #2f5cff;
      font-weight: 700;
      padding: 10px 12px;
      border-radius: 12px;
      font-size: 14px;
    }
    .danger {
      background: #ffecec;
      color: #cc1f1a;
      font-weight: 800;
      padding: 10px 12px;
      border-radius: 12px;
      font-size: 14px;
    }
    .bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      margin-top: 12px;
      font-size: 13px;
      color: #444;
      flex-wrap: wrap;
    }
    .bottom-actions {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      margin-top: 14px;
    }
    .bar button {
      padding: 10px 12px;
      border-radius: 12px;
      font-size: 14px;
    }
    .bar .mini { background:#111; }

    @media (max-width: 420px) {
      .row { flex-direction: column; }
      button { width: 100%; }
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="card">
      <h1>ğŸ“ Mini Taskï¼ˆã‚¿ãƒƒãƒ—ã§å®Œäº†ï¼‰</h1>

      <div class="row">
        <textarea id="taskInput" rows="2" placeholder="ã‚¿ã‚¹ã‚¯ã‚’æ›¸ãï¼ˆä¾‹ï¼šãƒ¡ãƒ¼ãƒ«ã‚’3é€šã ã‘è¿”ã™ï¼‰"></textarea>
        <button id="voiceBtn" class="voice" type="button">éŸ³å£°å…¥åŠ›</button>
        <button id="addBtn">è¿½åŠ </button>
      </div>
      <div id="voiceStatus" class="voice-status"></div>

      <div class="bar">
        <div id="count">0ä»¶</div>
      </div>

      <ul id="taskList"></ul>

      <div class="bottom-actions">
        <button class="ghost" id="exportDoneBtn" type="button">å®Œäº†ã‚’CSV</button>
        <button class="ghost" id="clearDoneBtn" type="button">å®Œäº†ã‚’å‰Šé™¤</button>
        <button class="mini" id="clearAllBtn" type="button">å…¨éƒ¨å‰Šé™¤</button>
      </div>
    </div>
  </div>

  <script>
    const KEY = "mini_task_v1";

    const input = document.getElementById("taskInput");
    const list = document.getElementById("taskList");
    const count = document.getElementById("count");
    const addBtn = document.getElementById("addBtn");
    const voiceBtn = document.getElementById("voiceBtn");
    const voiceStatus = document.getElementById("voiceStatus");
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    let recognition = null;
    let listening = false;
    let voiceText = "";

    function load() {
      try {
        const raw = JSON.parse(localStorage.getItem(KEY));
        if (!Array.isArray(raw)) return [];
        return raw.map((t) => ({
          text: typeof t?.text === "string" ? t.text : "",
          done: Boolean(t?.done),
          ts: Number.isFinite(t?.ts) ? t.ts : Date.now()
        })).filter((t) => t.text.trim() !== "");
      } catch {
        return [];
      }
    }
    function save(tasks) {
      localStorage.setItem(KEY, JSON.stringify(tasks));
    }

    function escapeHtml(str) {
      return String(str).replace(/[&<>"']/g, s => (
        { "&":"&amp;", "<":"&lt;", ">":"&gt;", '"':"&quot;", "'":"&#039;" }[s]
      ));
    }

    function render() {
      const tasks = load();
      list.innerHTML = "";

      tasks.forEach((t, i) => {
        const li = document.createElement("li");
        li.className = t.done ? "done" : "";
        li.innerHTML = `
          <div class="text">${escapeHtml(t.text)}</div>
          <div class="actions">
            <button class="ghost" data-act="toggle" data-idx="${i}" type="button">${t.done ? "æˆ»ã™" : "å®Œäº†"}</button>
            <button class="danger" data-act="del" data-idx="${i}" type="button">å‰Šé™¤</button>
          </div>
        `;

        // è¡Œã‚’ã‚¿ãƒƒãƒ—ã§å®Œäº†åˆ‡æ›¿ï¼ˆãƒœã‚¿ãƒ³ä»¥å¤–ï¼‰
        li.addEventListener("click", (e) => {
          const btn = e.target.closest("button");
          if (btn) return;
          toggle(i);
        });

        list.appendChild(li);
      });

      const total = tasks.length;
      const done = tasks.filter(t => t.done).length;
      count.textContent = `${total}ä»¶ï¼ˆå®Œäº† ${done}ï¼‰`;
    }

    function addTask() {
      const text = input.value.trim();
      if (!text) return;

      const tasks = load();
      tasks.unshift({ text, done: false, ts: Date.now() });
      save(tasks);

      input.value = "";
      input.focus();
      render();
    }

    function joinTexts(base, addition) {
      const a = base.trim();
      const b = addition.trim();
      if (!a) return b;
      if (!b) return a;
      return `${a} ${b}`;
    }

    function setVoiceStatus(message, isError = false) {
      voiceStatus.textContent = message;
      voiceStatus.style.color = isError ? "#b42318" : "#0f766e";
    }

    function updateVoiceButton() {
      if (!SpeechRecognition) {
        voiceBtn.disabled = true;
        voiceBtn.classList.remove("listening");
        setVoiceStatus("ã“ã®ãƒ–ãƒ©ã‚¦ã‚¶ã¯éŸ³å£°å…¥åŠ›ã«å¯¾å¿œã—ã¦ã„ã¾ã›ã‚“ã€‚", true);
        return;
      }
      voiceBtn.disabled = false;
      voiceBtn.classList.toggle("listening", listening);
      voiceBtn.textContent = listening ? "åœæ­¢" : "éŸ³å£°å…¥åŠ›";
      if (!listening && !voiceStatus.textContent) {
        setVoiceStatus("ãƒã‚¤ã‚¯ã‚’æŠ¼ã—ã¦è©±ã—ã¦ãã ã•ã„ã€‚");
      }
    }

    function setupVoiceInput() {
      if (!SpeechRecognition) {
        updateVoiceButton();
        return;
      }

      recognition = new SpeechRecognition();
      recognition.lang = "ja-JP";
      recognition.interimResults = true;
      recognition.continuous = false;

      recognition.addEventListener("start", () => {
        listening = true;
        voiceText = input.value.trim();
        updateVoiceButton();
        setVoiceStatus("èãå–ã‚Šä¸­...");
      });

      recognition.addEventListener("result", (event) => {
        let finalPart = "";
        let interimPart = "";
        for (let i = event.resultIndex; i < event.results.length; i += 1) {
          const transcript = event.results[i][0]?.transcript ?? "";
          if (event.results[i].isFinal) finalPart += transcript;
          else interimPart += transcript;
        }
        if (finalPart) voiceText = joinTexts(voiceText, finalPart);
        input.value = joinTexts(voiceText, interimPart);
      });

      recognition.addEventListener("error", (event) => {
        if (event.error === "not-allowed") {
          setVoiceStatus("ãƒã‚¤ã‚¯æ¨©é™ãŒæ‹’å¦ã•ã‚Œã¾ã—ãŸã€‚ãƒ–ãƒ©ã‚¦ã‚¶è¨­å®šã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚", true);
        } else if (event.error === "no-speech") {
          setVoiceStatus("éŸ³å£°ã‚’èªè­˜ã§ãã¾ã›ã‚“ã§ã—ãŸã€‚ã‚‚ã†ä¸€åº¦ãŠè©¦ã—ãã ã•ã„ã€‚", true);
        } else {
          setVoiceStatus(`éŸ³å£°å…¥åŠ›ã§ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: ${event.error}`, true);
        }
      });

      recognition.addEventListener("end", () => {
        listening = false;
        updateVoiceButton();
        if (!voiceStatus.textContent || voiceStatus.textContent === "èãå–ã‚Šä¸­...") {
          setVoiceStatus("éŸ³å£°å…¥åŠ›ã‚’çµ‚äº†ã—ã¾ã—ãŸã€‚å¿…è¦ãªã‚‰ã€Œè¿½åŠ ã€ã‚’æŠ¼ã—ã¦ãã ã•ã„ã€‚");
        }
        input.focus();
      });

      voiceBtn.addEventListener("click", () => {
        if (listening) {
          recognition.stop();
          return;
        }
        try {
          recognition.start();
        } catch {
          setVoiceStatus("éŸ³å£°å…¥åŠ›ã‚’é–‹å§‹ã§ãã¾ã›ã‚“ã§ã—ãŸã€‚å°‘ã—å¾…ã£ã¦å†è©¦è¡Œã—ã¦ãã ã•ã„ã€‚", true);
        }
      });

      updateVoiceButton();
    }

    function toggle(idx) {
      const tasks = load();
      if (!tasks[idx]) return;
      tasks[idx].done = !tasks[idx].done;
      save(tasks);
      render();
    }

    function del(idx) {
      const tasks = load();
      tasks.splice(idx, 1);
      save(tasks);
      render();
    }

    function clearDone() {
      const tasks = load().filter(t => !t.done);
      save(tasks);
      render();
    }

    function clearAll() {
      save([]);
      render();
    }

    function toCsvCell(value) {
      const text = String(value ?? "");
      return `"${text.replace(/"/g, '""')}"`;
    }

    function exportDoneCsv() {
      const doneTasks = load().filter((t) => t.done);
      if (doneTasks.length === 0) {
        setVoiceStatus("å®Œäº†ã‚¿ã‚¹ã‚¯ãŒãªã„ãŸã‚ã€CSVã‚’å‡ºåŠ›ã—ã¾ã›ã‚“ã§ã—ãŸã€‚", true);
        return;
      }

      const header = ["task", "created_at_iso", "done"];
      const rows = doneTasks.map((t) => [
        t.text,
        new Date(t.ts).toISOString(),
        "true"
      ]);
      const csv = [header, ...rows]
        .map((cols) => cols.map(toCsvCell).join(","))
        .join("\n");

      const blob = new Blob(["\uFEFF" + csv], { type: "text/csv;charset=utf-8;" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      const ymd = new Date().toISOString().slice(0, 10);
      a.href = url;
      a.download = `mini-task-done-${ymd}.csv`;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);

      setVoiceStatus(`${doneTasks.length}ä»¶ã®å®Œäº†ã‚¿ã‚¹ã‚¯ã‚’CSVå‡ºåŠ›ã—ã¾ã—ãŸã€‚`);
    }

    // è¿½åŠ ã¯ã€Œãƒœã‚¿ãƒ³ã®ã¿ã€(Enterã‚„IMEå¤‰æ›ç¢ºå®šã§å¢—ãˆãªã„)
    addBtn.addEventListener("click", addTask);

    // ã‚¿ã‚¹ã‚¯æ“ä½œãƒœã‚¿ãƒ³ï¼ˆå§”è­²ï¼‰
    document.addEventListener("click", (e) => {
      const btn = e.target.closest("button");
      if (!btn) return;

      const act = btn.dataset.act;
      if (!act) return;

      const idx = Number(btn.dataset.idx);
      if (act === "toggle") toggle(idx);
      if (act === "del") del(idx);
    });

    document.getElementById("clearDoneBtn").addEventListener("click", clearDone);
    document.getElementById("clearAllBtn").addEventListener("click", clearAll);
    document.getElementById("exportDoneBtn").addEventListener("click", exportDoneCsv);
    setupVoiceInput();

    render();
  </script>
  <script>
    if ("serviceWorker" in navigator) {
      window.addEventListener("load", () => {
        navigator.serviceWorker.register("./sw.js");
      });
    }
  </script>
</body>
</html>
